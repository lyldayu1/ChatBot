{
  "_from": "sql",
  "_id": "sql@0.78.0",
  "_inBundle": false,
  "_integrity": "sha1-iUWF1WER27F2h0Gk2ZNcgshZWUk=",
  "_location": "/sql",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "sql",
    "fetchSpec": "latest",
    "name": "sql",
    "raw": "sql",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/sql/-/sql-0.78.0.tgz",
  "_shasum": "894585d56111dbb1768741a4d9935c82c8595949",
  "_spec": "sql",
  "_where": "/Users/zhenghaoli/Desktop/bot",
  "author": {
    "email": "brian.m.carlson@gmail.com",
    "name": "brianc"
  },
  "bugs": {
    "url": "https://github.com/brianc/node-sql/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "lodash": "4.1.x",
    "sliced": "0.0.x"
  },
  "deprecated": false,
  "description": "sql builder",
  "devDependencies": {
    "jshint": "*",
    "mocha": "*"
  },
  "engines": {
    "node": "*"
  },
  "homepage": "https://github.com/brianc/node-sql",
  "license": "MIT",
  "main": "lib/",
  "name": "sql",
  "optionalDependencies": {},
  "readme": "# node-sql\n_sql string builder for node_ - supports PostgreSQL, mysql, Microsoft SQL Server, Oracle and sqlite dialects.\n\nBuilding SQL statements by hand is no fun, especially in a language which has clumsy support for multi-line strings.\n\nSo let's build it with JavaScript.\n\nMaybe it's still not fun, but at least it's _less not fun_.\n\n[![Build Status](https://secure.travis-ci.org/brianc/node-sql.png)](http://travis-ci.org/brianc/node-sql)\n\n## install\n\n```sh\n$ npm install sql\n```\n\n## use\n\n```js\n//require the module\nvar sql = require('sql');\n\n//(optionally) set the SQL dialect\nsql.setDialect('postgres');\n//possible dialects: mssql, mysql, postgres (default), sqlite\n\n//first we define our tables\nvar user = sql.define({\n  name: 'user',\n  columns: ['id', 'name', 'email', 'lastLogin']\n});\n\nvar post = sql.define({\n  name: 'post',\n  columns: ['id', 'userId', 'date', 'title', 'body']\n});\n\n//now let's make a simple query\nvar query = user.select(user.star()).from(user).toQuery();\nconsole.log(query.text); //SELECT \"user\".* FROM \"user\"\n\n//something more interesting\nvar query = user\n    .select(user.id)\n    .from(user)\n    .where(\n      user.name.equals('boom').and(user.id.equals(1))\n    ).or(\n      user.name.equals('bang').and(user.id.equals(2))\n    ).toQuery();\n\n//query is parameterized by default\nconsole.log(query.text); //SELECT \"user\".\"id\" FROM \"user\" WHERE (((\"user\".\"name\" = $1) AND (\"user\".\"id\" = $2)) OR ((\"user\".\"name\" = $3) AND (\"user\".\"id\" = $4)))\n\nconsole.log(query.values); //['boom', 1, 'bang', 2]\n\n//queries can be named\nvar query = user.select(user.star()).from(user).toNamedQuery('user.all');\nconsole.log(query.name); //'user.all'\n\n//how about a join?\nvar query = user.select(user.name, post.body)\n  .from(user.join(post).on(user.id.equals(post.userId))).toQuery();\n\nconsole.log(query.text); //'SELECT \"user\".\"name\", \"post\".\"body\" FROM \"user\" INNER JOIN \"post\" ON (\"user\".\"id\" = \"post\".\"userId\")'\n\n//this also makes parts of your queries composable, which is handy\n\nvar friendship = sql.define({\n  name: 'friendship',\n  columns: ['userId', 'friendId']\n});\n\nvar friends = user.as('friends');\nvar userToFriends = user\n  .leftJoin(friendship).on(user.id.equals(friendship.userId))\n  .leftJoin(friends).on(friendship.friendId.equals(friends.id));\n\n//and now...compose...\nvar friendsWhoHaveLoggedInQuery = user.from(userToFriends).where(friends.lastLogin.isNotNull());\n//SELECT * FROM \"user\"\n//LEFT JOIN \"friendship\" ON (\"user\".\"id\" = \"friendship\".\"userId\")\n//LEFT JOIN \"user\" AS \"friends\" ON (\"friendship\".\"friendId\" = \"friends\".\"id\")\n//WHERE \"friends\".\"lastLogin\" IS NOT NULL\n\nvar friendsWhoUseGmailQuery = user.from(userToFriends).where(friends.email.like('%@gmail.com'));\n//SELECT * FROM \"user\"\n//LEFT JOIN \"friendship\" ON (\"user\".\"id\" = \"friendship\".\"userId\")\n//LEFT JOIN \"user\" AS \"friends\" ON (\"friendship\".\"friendId\" = \"friends\".\"id\")\n//WHERE \"friends\".\"email\" LIKE %1\n\n//Using different property names for columns\n//helpful if your column name is long or not camelCase\nvar user = sql.define({\n  name: 'user',\n  columns: [{\n      name: 'id'\n    }, {\n      name: 'state_or_province',\n      property: 'state'\n    }\n  ]\n});\n\n//now, instead of user.state_or_province, you can just use user.state\nconsole.log(user.select().where(user.state.equals('WA')).toQuery().text);\n// \"SELECT \"user\".* FROM \"user\" WHERE (\"user\".\"state_or_province\" = $1)\"\n```\n\nThere are a __lot__ more examples included in the [test/dialects](https://github.com/brianc/node-sql/tree/master/test/dialects) folder.  We encourage you to read through them if you have any questions on usage!\n\n## from the command line\nYou can use the [sql-generate module](https://github.com/tmont/node-sql-generate)\nto automatically generate definition files from a database instance. For example,\nrunning `node-sql-generate --dsn \"mysql://user:password@host/database\"` will generate\nsomething similar to:\n\n```javascript\n// autogenerated by node-sql-generate v0.0.1 on Tue May 21 2013 01:04:12 GMT-0700 (PDT)\nvar sql = require('sql');\n\n/**\n * SQL definition for database.bar\n */\nexports.bar = sql.define({\n    name: 'bar',\n    columns: [\n        'id',\n        'foo_id'\n    ]\n});\n\n/**\n * SQL definition for database.foo\n */\nexports.foo = sql.define({\n    name: 'foo',\n    columns: [\n        'id',\n        'field_1',\n        'foo_bar_baz'\n    ]\n});\n\n/**\n * Adding a column to an existing table:\n */\nvar model = sql.define({ name: 'foo', columns: [] });\nmodel.addColumn('id');\n\n// If you try to add another column \"id\", node-sql will throw an error.\n// You can suppress that error via:\nmodel.addColumn('id', { noisy: false });\n```\n\nRead the module's documentation for more details.\n\n## contributing\n\nWe __love__ contributions.\n\nnode-sql wouldn't be anything without all the contributors and collaborators who've worked on it.\nIf you'd like to become a collaborator here's how it's done:\n\n1. fork the repo\n2. `git pull https://github.com/(your_username)/node-sql`\n3. `cd node-sql`\n4. `npm install`\n5. `npm test`\n\nAt this point the tests should pass for you.  If they don't pass please open an issue with the output or you can even send me an email directly.\nMy email address is on my github profile and also on every commit I contributed in the repo.\n\nOnce the tests are passing, modify as you see fit.  _Please_ make sure you write tests to cover your modifications.  Once you're ready, commit your changes and submit a pull request.\n\n__As long as your pull request doesn't have completely off-the-wall changes and it does have tests we will almost always merge it and push it to npm__\n\nIf you think your changes are too off-the-wall, open an issue or a pull-request without code so we can discuss them before you begin.\n\nUsually after a few high-quality pull requests and friendly interactions we will gladly share collaboration rights with you.\n\nAfter all, open source belongs to everyone.\n\n\n## license\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/brianc/node-sql.git"
  },
  "scripts": {
    "lint": "jshint lib test",
    "posttest": "jshint lib test",
    "test": "mocha"
  },
  "types": "lib/types.d.ts",
  "version": "0.78.0"
}
